# DES 초심자 가이드 (상세 버전)

이 문서는 DES 암호화 구현을 처음 접하는 사람도 쉽게 이해할 수 있도록, 전체 로직과 개념을 단계별로 상세히 설명한 가이드입니다. 기반 파일은 다음과 같습니다:

- `DES_table.py`: 테이블 정의 파일
- `DES.py`: DES 알고리즘 전체 구현
- `DES_example.py`: 사용 예시 코드

> ⚠️ 본 구현은 학습 및 실습용이며, 실제 보안 환경에서는 사용하지 마십시오.
> 

---

## 0. 사전 기초 개념

### 테이블이란?

DES에서의 "테이블"은 **비트를 선택하거나 순서를 바꾸기 위한 고정된 배열**입니다. 예를 들어 64비트 입력에서 특정 비트들을 뽑아 56비트로 만들거나, 특정 순서로 재배열할 때 사용됩니다. 테이블은 암호화 흐름을 고정시키고, 특정한 구조적 효과(확산, 혼돈)를 유도합니다.

### 대칭키 암호화란?

대칭키 암호화는 **하나의 동일한 키**를 사용하여 데이터를 암호화하고 복호화하는 방식입니다. 즉, 암호화할 때 사용한 키가 복호화할 때도 그대로 사용됩니다. DES는 대표적인 대칭키 알고리즘입니다.

### 패리티 비트란?

패리티 비트는 데이터의 오류를 감지하기 위한 **추가 비트**입니다. DES에서는 64비트 키를 입력받지만, 실제 키로 사용되는 건 그 중 56비트이며, 나머지 8비트는 각 바이트마다 하나씩 존재하는 패리티 비트입니다.

### XOR 연산이란?

XOR(배타적 논리합)은 다음과 같은 논리 연산입니다:

| A | B | A XOR B |
| --- | --- | --- |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

XOR은 암호화 알고리즘에서 핵심적인 연산으로, **비트를 뒤섞는 역할**을 합니다.

---

## 1. DES 개요

- **64비트 블록** 단위로 암호화
- **대칭키 방식** (암호화/복호화에 동일 키 사용)
- **총 16라운드** Feistel 네트워크 구조

---

## 2. 테이블 정의 (`DES_table.py`)

| 테이블 이름 | 용도 |
| --- | --- |
| `IP` | 평문에 초기 순열을 적용 (64비트 재배열) |
| `IP_INV` | 마지막에 결과를 원래 순서로 복원 |
| `E` | 32비트 R → 48비트로 확장 |
| `S_BOX` | 6비트 입력 → 4비트 출력 비선형 치환 |
| `P` | S-box 출력 순열 (확산 증가) |
| `PC_1` | 키에서 패리티 제거 + 재배열 (64 → 56비트) |
| `PC_2` | C, D 합쳐서 48비트 선택 (서브키 생성) |
| `SHIFT_TABLE` | 각 라운드에서 C, D 좌측 순환 횟수 지정 |

---

## 3. 연산 함수 전체 설명 (`DES.py`)

### ▶ `permute(bits, table)`

- 주어진 비트 리스트에서 `table`에 명시된 순서대로 비트를 재배열함
- 예: `table = [3, 1, 2]` → 3번째, 1번째, 2번째 비트 순서로 반환

### ▶ `xor(bits1, bits2)`

- 같은 길이의 두 비트 리스트를 요소별 XOR
- 암호화에서 L ⊕ f(R, K) 계산에 사용됨

### ▶ `left_shift(bits, n)`

- 비트 리스트를 왼쪽으로 n비트 순환 이동 (rotate left)
- 키 스케줄에서 C, D에 적용됨

### ▶ `pad_bitlist(bits)` / `unpad_bitlist(bits)`

- PKCS#5 방식 패딩 처리
- 블록이 64비트 단위가 아닐 경우 패딩하여 맞춤

---

## 4. 키 스케줄: `generate_keys(key_64)`

1. `PC_1`으로 64비트 키 → 56비트
2. C, D로 28비트씩 분할
3. 16라운드 동안 `SHIFT_TABLE`에 따라 좌측 이동
4. 각 라운드마다 `PC_2`로 48비트 서브키 생성

최종 결과: `round_keys[0~15]` = 각 라운드의 키

---

## 5. f 함수: `f_function(R, K)`

Feistel 구조에서 사용되는 핵심 연산 함수:

1. `E`로 32비트 R → 48비트로 확장
2. XOR: 확장된 R ⊕ 라운드 키 K
3. 6비트씩 8블록 → 각각 S-Box 적용 (6 → 4비트)
4. 32비트 결과에 `P` 순열 적용 → 최종 출력

---

## 6. 블록 단위 암호화: `encrypt_block()` / `decrypt_block()`

- `IP`로 입력 비트 순열 → L0, R0 분할
- 16라운드 Feistel 반복:
    - L, R 갱신: `L_next = R`, `R_next = L ⊕ f(R, K)`
- 마지막에 L, R 스왑 후 `IP_INV` 적용
- 복호화는 키를 역순으로 넣기만 하면 구조는 동일

---

## 7. 전체 메시지 암호화 (ECB)

- 문자열을 64비트 단위로 나누고 각 블록에 암호화 적용
- `des_encrypt()` / `des_decrypt()` 사용
- 각 블록은 독립적으로 처리됨 (병렬화 가능)

---

## 8. CBC 모드 암호화

- `IV` (초기화 벡터) 필요
- 각 블록은 **이전 암호문과 XOR 후 암호화**
- 복호화 시에는 **복호화된 값과 이전 암호문 XOR**

함수:

- `des_encrypt_cbc(plaintext, key, iv)`
- `des_decrypt_cbc(ciphertext, key, iv)`

---

> 본 가이드는 교육용 구현 기반이며, 실제 보안 환경에는 적합하지 않습니다.
>